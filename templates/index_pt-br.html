<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>{{ window_title }}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <style>
        .container { height: 100%; display: flex; flex-direction: column; }
        #main-content-area { flex-grow: 1; padding-right: 15px; }
        #duplicate-selection { padding: 20px; border: 1px solid #ccc; border-radius: 8px; margin-top: 20px; }
        #duplicates-list {
            max-height: 200px;
            overflow-y: auto;
            flex-grow: 1;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            padding: 10px;
            min-width: 0;
            --fade-amount: 8%; -webkit-mask-image: linear-gradient(to bottom, transparent, black var(--fade-amount), black calc(100% - var(--fade-amount)), transparent); mask-image: linear-gradient(to bottom, transparent, black var(--fade-amount), black calc(100% - var(--fade-amount)), transparent);
        }
        .button-container { cursor: pointer; }
        .config-gear { position: absolute; top: 10px; left: 10px; background: none; border: none; color: var(--gold-color); font-size: 20px; cursor: pointer; z-index: 1000; }
        
        /* Flash animations */
        @keyframes successFlash {
            0% { background-color: transparent; }
            50% { background-color: rgba(0, 255, 0, 0.3); }
            100% { background-color: transparent; }
        }
        
        @keyframes errorShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        
        .success-flash {
            animation: successFlash 0.8s ease-in-out;
        }
        
        .error-shake {
            animation: errorShake 0.6s ease-in-out;
        }
        .duplicate-item { display: flex; align-items: center; padding: 5px; border-bottom: 1px solid #eee; }
        #title-manager { margin-top: 20px; }
        #filtered-titles-list { list-style: none; padding: 0; max-height: 150px; overflow-y: auto; border: 1px solid #ddd; margin-bottom: 10px; }
        #filtered-titles-list li { display: flex; justify-content: space-between; align-items: center; padding: 5px 8px; border-bottom: 1px solid #eee; }
        .delete-title-btn { cursor: pointer; color: red; font-weight: bold; border: none; background: none; font-size: 1.2em; }
        
        /* <<< NOVO >>> Estilos para o seletor de modo */
        .input-mode-selector { display: flex; margin-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        .mode-btn { background: none; border: none; color: var(--text-color); padding: 10px 15px; cursor: pointer; font-size: 1em; border-bottom: 2px solid transparent; font-family: Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; }
        .mode-btn.active { color: var(--2-color); border-bottom-color: var(--2-color); font-weight: bold; }
        #text-content-area { width: 100%; min-height: 150px; margin-bottom: 10px; resize: vertical; }
    </style>
</head>
<body>
    <div class="titlebar" id="titlebar">
        <span class="titlebar-text"></span>
        <div class="window-controls">
            <button class="window-btn minimize" id="minimize-btn" title="Minimizar">–</button>
            <button class="window-btn" id="close-btn" title="Fechar">×</button>
        </div>
    </div>
    <div class="main-wrapper">
        <button class="config-gear" id="config-gear-btn" title="Configurações"></button>
        <div class="container" id="vcf-container">
        <h1>{{ window_title }}</h1>
        <div id="duplicate-selection-1" style="display: none; color: var(--2-color); font-family:Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;">Estes contatos já estão no registro. Selecione quais você deseja reprocessar.</div>

            <div id="main-content-area">
                <!-- <<< NOVO >>> Seletor de modo de entrada -->
                <div class="input-mode-selector" id="input-mode-selector">
                    <button id="mode-file-btn" class="mode-btn">Processar Arquivo VCF</button>
                    <button id="mode-text-btn" class="mode-btn active">Processar Lista de Texto</button>
                </div>

                <!-- <<< ALTERADO >>> Seção de formulário inicial agora dividida -->
                <div id="initial-form">
                    <!-- Seção para entrada de arquivo -->
                    <div id="file-input-section" style="display: none;">
                        <div class="input-field">
                            <label for="vcf-path">Arquivo VCF:</label>
                            <div style="display: contents;">
                                <input type="text" id="vcf-path" class="input-style" value="{{ initial_vcf_path }}" placeholder="Selecione um arquivo VCF para processar...">
                                <div class="button-container"><button type="button" id="browse-vcf-btn" class="button file-label">Procurar</button></div>
                            </div>
                        </div>
                        <div class="button-container"><button type="button" id="start-btn" class="button">Processar VCF</button></div>
                    </div>
                    <!-- <<< NOVO >>> Seção para entrada de texto -->
                    <div id="text-input-section">
                        <label for="text-content-area">Cole a lista de contatos aqui:</label>
                        <textarea id="text-content-area" class="input-style" placeholder="✅ Nome +55...&#10;Name: Outro Nome..."></textarea>
                        <div class="button-container"><button type="button" id="start-text-btn" class="button">Processar Texto</button></div>
                    </div>
                </div>

                <div id="duplicate-selection-2" style="display: none;">
                        <div style="display: flex; gap: 15px;">
                            <form id="duplicates-form" style="flex: 1;">
                                <input type="text" id="search-duplicates-input" placeholder="Buscar contatos..." class="input-style" style="margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                                    <input type="checkbox" id="select-all-checkbox" style="margin-right: 8px;">
                                    <label for="select-all-checkbox">Selecionar todos</label>
                                </div>
                                <div id="duplicates-list"></div>
                            </form>
                            <div class="button-container" style="flex-shrink: 0; width: 110px;">
                                <button id="submit-button" class="button" style="width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.9em;">Processar</button>
                            </div>
                        </div>
                    </div>

            </div>
            <div id="log-area" style="display: none; height: 90px;"></div>


</div>
<div id="advanced-panel">
    <div id="panel-tab">
    <img src="static/wheel.svg" alt="Settings">
</div>


    <div id="advanced-panel-content" class="advanced-panel">
        <h3 class="h3">Configurações</h3>
            <div id="light-mode-toggle">
                <label>
                    <input type="checkbox" id="lightModeSwitch">
                    <span class="slider"></span>
                </label>
                <span style="color: var(--gold-color); font-family: Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; text-align: right;">Efeitos de Luz</span>
            </div>

        <div id="title-manager">
            <h4 class="h4">Títulos Filtrados</h4>
            <p style="color: var(--gold-color); font-family: Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;">Palavras nesta lista serão removidas dos nomes.</p>
            <input type="text" id="search-titles-input" placeholder="Buscar títulos..." class="input-style-adv" style="margin-bottom: 10px;">
            <ul id="filtered-titles-list" style="color: var(--gold-color); font-family: Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;"></ul>
            <div class="input-field-adv">
        <textarea id="new-title-input" placeholder="Adicionar títulos (separados por vírgula ou nova linha)..." class="input-style-adv" rows="3" autofocus></textarea>
        <div class="button-container-adv"><button type="button" id="add-title-btn" class="button-adv">+</button></div>
            </div>
        </div>
        <hr>
        <div id="log-manager" style="margin-top: 20px;">
            <h4 class="h4">Lista de Números Processados</h4>
            <div id="view-log-file" class="button-container-adv">
                <button type="button" id="view-log-btn" class="button-adv">Ver Lista</button>
            </div>
        </div>
        <hr>
        <div id="update-manager" style="margin-top: 20px;">
            <h4 class="h4">Atualizações</h4>
            <div class="button-container-adv">
                <button type="button" id="check-updates-btn" class="button-adv">Verificar Atualizações</button>
            </div>
            <div id="update-status" style="margin-top: 10px; color: var(--gold-color); font-size: 0.9em;"></div>
        </div>
    </div>
</div>
    </div>

<script>
    // --- <<< NOVO >>> Adicionando referências aos novos elementos ---
    const modeFileBtn = document.getElementById('mode-file-btn');
    const modeTextBtn = document.getElementById('mode-text-btn');
    const fileInputSection = document.getElementById('file-input-section');
    const textInputSection = document.getElementById('text-input-section');
    const textContentArea = document.getElementById('text-content-area');
    const startTextBtn = document.getElementById('start-text-btn');

    let state = {
        isLoading: false,
        isProcessing: false,
        showAdvanced: false,
        vcfPath: document.getElementById('vcf-path').value,
        duplicates: [],
        filteredTitles: [],
        logMessages: [],
        error: null
    };


    let lightMode = 'follow'; // 'static' or 'follow'
    let currentLightX = window.innerWidth / 2;
    let currentLightY = window.innerHeight / 2;
    let targetLightX = currentLightX;
    let targetLightY = currentLightY;

    // On change, save preference
    document.getElementById('lightModeSwitch').addEventListener('change', () => {
        lightMode = document.getElementById('lightModeSwitch').checked ? 'follow' : 'static';
        updateLightPosition();
        fetch('/save_light_mode', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ lightMode })
        });
    });



    document.addEventListener('mousemove', (e) => {
        if (lightMode === 'follow') {
            targetLightX = e.clientX;
            targetLightY = e.clientY;
        }
    });

    let lastUpdateTime = 0;
    const updateInterval = 16; // ~60fps

    function updateShadows(timestamp) {
        if (timestamp - lastUpdateTime < updateInterval) {
            requestAnimationFrame(updateShadows);
            return;
        }
        lastUpdateTime = timestamp;
        
        // Smooth interpolation (lerp) for stability
        const lerp = 0.1;
        const prevX = currentLightX;
        const prevY = currentLightY;
        currentLightX += (targetLightX - currentLightX) * lerp;
        currentLightY += (targetLightY - currentLightY) * lerp;
        
        // Only update if movement is significant (>1px)
        const deltaX = Math.abs(currentLightX - prevX);
        const deltaY = Math.abs(currentLightY - prevY);
        
        if (deltaX > 1 || deltaY > 1) {
            let light = document.querySelector('.light');
            if (!light) {
                light = document.createElement('div');
                light.className = 'light';
                document.body.appendChild(light);
            }
            
            light.style.left = `${currentLightX}px`;
            light.style.top = `${currentLightY}px`;
            
            // Only update shadows for visible elements
            const visibleElements = document.querySelectorAll('.input-style, .advanced-panel, h1, h3, h4, label');
            visibleElements.forEach(el => {
                const rect = el.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const dx = centerX - currentLightX;
                const dy = centerY - currentLightY;
                const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 50); // Minimum distance of 50px
                const offsetX = Math.min(Math.max((dx / dist) * 2, -3), 3); // Clamp between -3 and 3
                const offsetY = Math.min(Math.max((dy / dist) * 2, -3), 3); // Clamp between -3 and 3
                el.style.textShadow = `${offsetX}px ${offsetY}px 5px rgba(0,0,0,0.5)`;
                if(el.classList.contains('input-style') || el.classList.contains('advanced-panel')) {
                    el.style.boxShadow = `${offsetX}px ${offsetY}px 10px rgba(0,0,0,0.3)`;
                }
            });
        }
        
        requestAnimationFrame(updateShadows);
    }

    // Start the smooth animation loop
    requestAnimationFrame(updateShadows);

    // For static mode:
    function updateLightPosition() {
        if (lightMode === 'static') {
            targetLightX = window.innerWidth / 2;
            targetLightY = window.innerHeight / 2;
        }
    }
    // Call updateLightPosition initially for static mode if needed
    if (lightMode === 'static') updateLightPosition();

    // --- Global State & Element References ---
    const vcfPathInput = document.getElementById('vcf-path');
    const startBtn = document.getElementById('start-btn');
    const logArea = document.getElementById('log-area');
    const initialForm = document.getElementById('initial-form');
    const duplicateSelectionDiv1 = document.getElementById('duplicate-selection-1');
    const duplicateSelectionDiv2 = document.getElementById('duplicate-selection-2');
    //const duplicateSelectionDiv3 = document.getElementById('duplicate-selection-3');
    const duplicatesForm = document.getElementById('duplicates-form');
    const duplicatesList = document.getElementById('duplicates-list');
    const titlesList = document.getElementById('filtered-titles-list');
    const newTitleInput = document.getElementById('new-title-input');
    const addTitleBtn = document.getElementById('add-title-btn');
    const searchTitlesInput = document.getElementById('search-titles-input');
    const advancedPanel = document.getElementById('advanced-panel');
    const selectAllCheckbox = document.getElementById('select-all-checkbox');
    const searchDuplicatesInput = document.getElementById('search-duplicates-input');
    const submitButton = document.getElementById('submit-button');
    const viewLogBtn = document.getElementById('view-log-btn');
    const browseVcfBtn = document.getElementById('browse-vcf-btn');
    const configGearBtn = document.getElementById('config-gear-btn');
    const inputModeSelector = document.getElementById('input-mode-selector');
    const checkUpdatesBtn = document.getElementById('check-updates-btn');
    const updateStatus = document.getElementById('update-status');
    const closeBtn = document.getElementById('close-btn');
    const minimizeBtn = document.getElementById('minimize-btn');
    const titlebar = document.getElementById('titlebar');


    // --- State Management ---
    function setState(newState) {
        state = { ...state, ...newState };
        render(state);
    }

    // --- Helper Functions (defined at top level) ---
    function logMessage(message) {
        // Append the new message to a *copy* of the logMessages array
        const newLogMessages = [...state.logMessages, message];
        // Update state with the new array
        setState({ logMessages: newLogMessages });
    }

    async function fetchAndDisplayTitles() {
        try {
            const response = await fetch('/get_titles');
            const data = await response.json();
            setState({ filteredTitles: data.titles }); // Update state, render will handle display
        } catch (e) {
            console.error("Failed to fetch titles:", e);
            logMessage(`Erro ao carregar títulos: ${e.message}`); // Log error via state
        }
    }

    async function saveTitles() {
        setState({ isLoading: true }); // Indicate saving is in progress
        const currentTitles = state.filteredTitles; // Use state for current titles
        try {
            await fetch('/save_titles', {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ titles: currentTitles })
            });
            logMessage("Lista de títulos filtrados atualizada.");
        } catch (e) {
             logMessage(`Erro ao salvar títulos: ${e.message}`); // Log error via state
        } finally {
             setState({ isLoading: false }); // Indicate saving is done
        }
    }

    function showSuccessFlash() {
        document.body.classList.add('success-flash');
        setTimeout(() => {
            document.body.classList.remove('success-flash');
        }, 800);
    }
    
    function showErrorShake() {
        document.body.classList.add('error-shake');
        setTimeout(() => {
            document.body.classList.remove('error-shake');
        }, 600);
    }

    async function continueProcessing(selected_duplicates) {
        setState({ isProcessing: true, duplicates: [], logMessages: [] }); // Clear duplicates, start processing state, clear logs
        logMessage(`Continuando com ${selected_duplicates.length} duplicatas selecionadas...`);
        try {
            const response = await fetch('/reprocess_selected', {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ selected_to_reprocess: selected_duplicates })
            });
            const data = await response.json();
            if (response.ok) {
                 if (data.output_file && data.output_file !== "None") {
                    logMessage(`<strong>${data.message}</strong> Arquivo de saída: <a href="#" class="output-link" data-path="${data.output_file}">${data.output_file}</a>`);
                    showSuccessFlash();
                } else {
                    logMessage(`<strong>${data.message}</strong> Nenhum arquivo de saída foi criado.`);
                    showErrorShake();
                }
            } else {
                throw new Error(data.error || 'An unknown server error occurred.');
            }
        } catch (error) {
             logMessage(`Erro: ${error.message}`); // Log error via state
             showErrorShake();
        } finally {
             setState({ isProcessing: false, duplicates: [] }); // End processing, clear duplicates
        }
    }

    // Function to update submit button text based on checked checkboxes
    function updateSubmitButtonText() {
        const checkedCheckboxes = duplicatesList.querySelectorAll('input[type="checkbox"]:checked').length;
        if (checkedCheckboxes > 0) {
            submitButton.textContent = 'Processar Selecionados';
        } else {
            submitButton.textContent = 'Pular';
        }
    }

    function showDuplicateSelector(duplicates) {
        setState({ duplicates: duplicates });
        logMessage(`Encontradas ${duplicates.length} duplicatas. Por favor, faça sua seleção.`);
        
        // No need for separate optimization - handled in render function
    }

    // Define the new function to handle dropped or selected VCF paths
    async function handleVcfPathReady(vcfPath) {
         if (!vcfPath) {
            logMessage("Nenhum caminho de arquivo válido fornecido para processamento.");
            // Also clear the state's vcfPath if the input is cleared
            setState({ vcfPath: '', isLoading: false });
            return;
        }

        // Update the input field and state
        setState({ vcfPath: vcfPath, isLoading: true, logMessages: [] }); // Start loading state, clear logs
        logMessage(`Processando arquivo VCF: ${vcfPath}...`);

        try {
            const response = await fetch('/process_dropped_vcf', { // Use the dedicated dropped/selected route
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ vcf_path: vcfPath })
            });

            const data = await response.json();

            if (response.ok) {
                // Handle auto-processed files when no duplicates found
                if (data.output_file && data.output_file !== "None") {
                    logMessage(`<strong>${data.message || 'Processing complete!'}</strong> Arquivo de saída: <a href="#" class="output-link" data-path="${data.output_file}">${data.output_file}</a>`);
                    showSuccessFlash();
                    setState({ isLoading: false, isProcessing: false, duplicates: [], vcfPath: '', error: null });
                } else if (data.duplicates && data.duplicates.length > 0) {
                    showDuplicateSelector(data.duplicates);
                    setState({ isLoading: false });
                    updateSubmitButtonText();
                } else {
                    logMessage("Nenhuma duplicata encontrada. Processamento concluído.");
                    showSuccessFlash();
                    setState({ isLoading: false, isProcessing: false, duplicates: [], vcfPath: '', error: null });
                }
            } else {
                // Handle server errors
                throw new Error(data.error || 'An unknown server error occurred.');
            }

        } catch (error) {
            // Handle network or other fetch errors
            logMessage(`Erro ao processar arquivo: ${error.message}`); // Log error via state
            showErrorShake();
            setState({ isLoading: false }); // End loading state on error
        }
    }


    // --- Render Function ---
    function render(state) {
        // Update VCF Path input
        vcfPathInput.value = state.vcfPath;

        // Show/Hide sections based on state
        const showInitialForm = !state.isLoading && !state.isProcessing && state.duplicates.length === 0;
        const showDuplicateSelection = state.duplicates.length > 0 && !state.isProcessing;

        initialForm.style.display = showInitialForm ? 'block' : 'none';
        duplicateSelectionDiv1.style.display = showDuplicateSelection ? 'block' : 'none';
        duplicateSelectionDiv2.style.display = showDuplicateSelection ? 'block' : 'none';
        inputModeSelector.style.display = showDuplicateSelection ? 'none' : 'flex';
        //duplicateSelectionDiv3.style.display = showDuplicateSelection ? 'block' : 'none';

        // Enable/Disable buttons
        // Start button is enabled only if there's a vcfPath and not loading/processing
        startBtn.disabled = state.isLoading || state.isProcessing || !state.vcfPath;
        // <<< NOVO >>> Desabilita o botão de processar texto também
        startTextBtn.disabled = state.isLoading || state.isProcessing;

        if (selectAllCheckbox) selectAllCheckbox.disabled = state.isLoading || state.isProcessing || state.duplicates.length === 0;
        if (searchDuplicatesInput) searchDuplicatesInput.disabled = state.isLoading || state.isProcessing;
        browseVcfBtn.disabled = state.isLoading || state.isProcessing;
        addTitleBtn.disabled = state.isLoading || state.isProcessing;
        viewLogBtn.disabled = state.isLoading || state.isProcessing;
        if (checkUpdatesBtn) checkUpdatesBtn.disabled = state.isLoading || state.isProcessing;
        newTitleInput.disabled = state.isLoading || state.isProcessing;
        if (searchTitlesInput) searchTitlesInput.disabled = state.isLoading || state.isProcessing;

        // Submit button text and disabled state
        const checkedCheckboxes = duplicatesList.querySelectorAll('input[type="checkbox"]:checked').length;
        if (state.duplicates.length > 0 && !state.isProcessing) {
            if (checkedCheckboxes > 0) {
                submitButton.textContent = 'Processar';
                submitButton.disabled = state.isLoading || state.isProcessing; // Disable if loading/processing
            } else {
                submitButton.textContent = 'Pular';
                submitButton.disabled = state.isLoading || state.isProcessing; // Disable if loading/processing
            }
        } else {
             submitButton.textContent = 'Processar'; // Default text when not in duplicate selection
             submitButton.disabled = true; // Disabled when not in duplicate selection
        }


        // Populate Duplicates List with search filter and virtual scrolling
        duplicatesList.innerHTML = ''; // Clear existing
        const duplicateSearchTerm = searchDuplicatesInput ? searchDuplicatesInput.value.toLowerCase() : '';
        const filteredDuplicates = duplicateSearchTerm ? 
            state.duplicates.filter(contact => 
                contact.original_name.toLowerCase().includes(duplicateSearchTerm) || 
                contact.cleaned_number.includes(duplicateSearchTerm)
            ) : state.duplicates;
        
        if (filteredDuplicates.length > 0) {
            if (state.duplicates.length > 1000) {
                // Virtual scrolling for very large lists
                const itemHeight = 40;
                const containerHeight = 400;
                const visibleItems = Math.ceil(containerHeight / itemHeight);
                const totalHeight = state.duplicates.length * itemHeight;
                
                duplicatesList.style.height = `${containerHeight}px`;
                duplicatesList.style.overflowY = 'auto';
                duplicatesList.innerHTML = `<div style="height: ${totalHeight}px; position: relative;"></div>`;
                
                const container = duplicatesList.firstChild;
                let startIndex = 0;
                
                function renderVisibleItems() {
                    const scrollTop = duplicatesList.scrollTop;
                    startIndex = Math.floor(scrollTop / itemHeight);
                    const endIndex = Math.min(startIndex + visibleItems + 5, state.duplicates.length);
                    
                    container.innerHTML = '';
                    for (let i = startIndex; i < endIndex; i++) {
                        const contact = state.duplicates[i];
                        const div = document.createElement('div');
                        div.className = 'duplicate-item';
                        div.style.position = 'absolute';
                        div.style.top = `${i * itemHeight}px`;
                        div.style.width = '100%';
                        div.style.height = `${itemHeight}px`;
                        const isSelected = state.duplicates.selectedAll || false;
                        div.innerHTML = `<input type="checkbox" id="dup-${i}" name="selected_duplicates" data-contact='${JSON.stringify(contact)}' ${isSelected ? 'checked' : ''}><label for="dup-${i}">${contact.original_name} (${contact.cleaned_number})</label>`;
                        container.appendChild(div);
                    }
                }
                
                duplicatesList.addEventListener('scroll', renderVisibleItems);
                renderVisibleItems();
            } else {
                // Standard rendering for smaller lists
                const fragment = document.createDocumentFragment();
                filteredDuplicates.forEach((contact, index) => {
                    const div = document.createElement('div');
                    div.className = 'duplicate-item';
                    div.innerHTML = `<input type="checkbox" id="dup-${index}" name="selected_duplicates" data-contact='${JSON.stringify(contact)}'><label for="dup-${index}">${contact.original_name} (${contact.cleaned_number})</label>`;
                    fragment.appendChild(div);
                });
                duplicatesList.appendChild(fragment);
            }
        }

        // Populate Filtered Titles List with search filter
        titlesList.innerHTML = ''; // Clear existing
        const titleSearchTerm = searchTitlesInput ? searchTitlesInput.value.toLowerCase() : '';
        const filteredTitles = titleSearchTerm ? 
            state.filteredTitles.filter(title => title.toLowerCase().includes(titleSearchTerm)) : 
            state.filteredTitles;
        
        if (filteredTitles.length > 0) {
            filteredTitles.forEach(title => {
                const li = document.createElement('li');
                li.textContent = title;
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '×';
                deleteBtn.className = 'delete-title-btn';
                li.appendChild(deleteBtn);
                titlesList.appendChild(li);
            });
        }

        // Toggle Advanced Panel visibility
        advancedPanel.classList.toggle('visible', state.showAdvanced);

        // Update Log Area
        logArea.style.display = state.logMessages.length > 0 ? 'block' : 'none';
        logArea.innerHTML = state.logMessages.join('<br>');
        logArea.scrollTop = logArea.scrollHeight; // Auto-scroll to bottom
    }


    // --- Main Initializer ---
    document.addEventListener('DOMContentLoaded', () => {
        // Attach all event listeners once the DOM is ready

        fetch('/get_light_mode')
            .then(response => response.json())
            .then(data => {
                lightMode = data.lightMode;
                document.getElementById('lightModeSwitch').checked = (lightMode === 'follow');
                updateLightPosition();
            });

        fetchAndDisplayTitles();
        // Initial render call - this will set the initial state based on Flask template values
        render(state);

        // Global drag and drop for VCF files
        document.addEventListener('dragover', (e) => {
            if (state.duplicates.length === 0) { // Only allow when not in duplicate selection
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            }
        });

        document.addEventListener('drop', (e) => {
            if (state.duplicates.length === 0) { // Only allow when not in duplicate selection
                e.preventDefault();
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.name.toLowerCase().endsWith('.vcf')) {
                        handleVcfPathReady(file.path || file.name);
                    }
                }
            }
        });

        // <<< NOVO >>> Lógica para alternar entre os modos de entrada
        modeFileBtn.addEventListener('click', () => {
            modeFileBtn.classList.add('active');
            modeTextBtn.classList.remove('active');
            fileInputSection.style.display = 'block';
            textInputSection.style.display = 'none';
        });

        modeTextBtn.addEventListener('click', () => {
            modeTextBtn.classList.add('active');
            modeFileBtn.classList.remove('active');
            textInputSection.style.display = 'block';
            fileInputSection.style.display = 'none';
        });

        // Add event listener for changes to the vcf-path input field
        vcfPathInput.addEventListener('input', (e) => {
            // Update the state when the input value changes
            setState({ vcfPath: e.target.value });
        });

        // Add event listener for the custom event dispatched by the backend on drop
        vcfPathInput.addEventListener('droppedFileReady', (e) => {
            // When a file is dropped and the backend updates the input,
            // this event fires. Get the path from the input and trigger processing.
            handleVcfPathReady(e.target.value);
        });


        // Event Delegation for Delete Title Buttons
        titlesList.addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-title-btn')) {
                const titleToRemove = e.target.parentElement.firstChild.textContent;
                setState({ filteredTitles: state.filteredTitles.filter(title => title !== titleToRemove) });
                saveTitles();
            }
        });

        addTitleBtn.addEventListener('click', () => {
            const input = newTitleInput.value.trim();
            if (input) {
                // Split by newlines and commas, then clean up
                const newTitles = input.split(/[\n,]+/)
                    .map(title => title.trim())
                    .filter(title => title && !state.filteredTitles.includes(title));
                
                if (newTitles.length > 0) {
                    setState({ filteredTitles: [...state.filteredTitles, ...newTitles] });
                    newTitleInput.value = '';
                    saveTitles();
                }
            }
        });

        newTitleInput.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const input = newTitleInput.value.trim();
                if (input) {
                    const newTitles = input.split(/[\n,]+/)
                        .map(title => title.trim())
                        .filter(title => title && !state.filteredTitles.includes(title));
                    
                    if (newTitles.length > 0) {
                        setState({ filteredTitles: [...state.filteredTitles, ...newTitles] });
                        newTitleInput.value = '';
                        await saveTitles();
                        newTitleInput.focus();
                        newTitleInput.select();
                    }
                }
            }
        });

        // Live search for titles
        searchTitlesInput.addEventListener('input', () => {
            render(state); // Re-render to apply search filter
        });
        // Event listener for changes within the duplicates list (checkbox clicks)
        duplicatesList.addEventListener('change', (e) => {
            if (e.target.tagName === 'INPUT' && e.target.type === 'checkbox') {
                updateSubmitButtonText();
            }
        });

        // Prevent text selection during drag and enable scroll wheel
        duplicatesList.addEventListener('selectstart', (e) => {
            if (isDragging) e.preventDefault();
        });
        
        duplicatesList.addEventListener('wheel', (e) => {
            e.stopPropagation();
        });

        // Function to update submit button text based on checked checkboxes
        function updateSubmitButtonText() {
            const checkedCheckboxes = duplicatesList.querySelectorAll('input[type="checkbox"]:checked').length;
            if (checkedCheckboxes > 0) {
                submitButton.textContent = 'Processar';
            } else {
                submitButton.textContent = 'Pular';
            }
        }


        let isDragging = false;
        let dragStarted = false;
        let lastSelectedItem = null;
        let dragMode = 'select'; // 'select' or 'unselect'
        let lastDragTime = 0;

        // Event listener for clicking on duplicate list items (to toggle checkbox)
        document.addEventListener('click', (e) => {
            if (duplicatesList.contains(e.target) && !dragStarted) {
                const duplicateItem = e.target.closest('.duplicate-item');
                if (duplicateItem && e.target.tagName !== 'INPUT' && e.target.tagName !== 'LABEL') {
                    const checkbox = duplicateItem.querySelector('input[type="checkbox"]');
                    if (checkbox) {
                        checkbox.checked = !checkbox.checked;
                        updateSubmitButtonText();
                    }
                }
            }
        });

        // Drag selection for duplicate items
        document.addEventListener('mousedown', (e) => {
            if (duplicatesList.contains(e.target)) {
                isDragging = true;
                dragStarted = false;
                const duplicateItem = e.target.closest('.duplicate-item');
                if (duplicateItem) {
                    const checkbox = duplicateItem.querySelector('input[type="checkbox"]');
                    dragMode = checkbox && checkbox.checked ? 'unselect' : 'select';
                }
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const now = Date.now();
                if (now - lastDragTime < 16) return; // Throttle to 60fps
                lastDragTime = now;
                
                dragStarted = true;
                const rect = duplicatesList.getBoundingClientRect();
                const scrollZone = 50;
                
                // Auto-scroll and select when near edges or outside
                if ((e.clientY < rect.top + scrollZone || e.clientY < rect.top) && duplicatesList.scrollTop > 0) {
                    duplicatesList.scrollTop -= 5;
                    setTimeout(() => {
                        const firstItem = duplicatesList.querySelector('.duplicate-item');
                        if (firstItem) {
                            const checkbox = firstItem.querySelector('input[type="checkbox"]');
                            if (checkbox) {
                                checkbox.checked = dragMode === 'select';
                                updateSubmitButtonText();
                            }
                        }
                    }, 5);
                } else if ((e.clientY > rect.bottom - scrollZone || e.clientY > rect.bottom)) {
                    duplicatesList.scrollTop += 5;
                    setTimeout(() => {
                        const items = duplicatesList.querySelectorAll('.duplicate-item');
                        const lastItem = items[items.length - 1];
                        if (lastItem) {
                            const checkbox = lastItem.querySelector('input[type="checkbox"]');
                            if (checkbox) {
                                checkbox.checked = dragMode === 'select';
                                updateSubmitButtonText();
                            }
                        }
                    }, 5);
                }
                
                // Select item under mouse
                if (duplicatesList.contains(e.target)) {
                    const duplicateItem = e.target.closest('.duplicate-item');
                    if (duplicateItem && duplicateItem !== lastSelectedItem) {
                        const checkbox = duplicateItem.querySelector('input[type="checkbox"]');
                        if (checkbox) {
                            checkbox.checked = dragMode === 'select';
                            updateSubmitButtonText();
                        }
                        lastSelectedItem = duplicateItem;
                    }
                }
            }
        });

        document.addEventListener('mouseup', () => {
            setTimeout(() => { dragStarted = false; }, 10);
            isDragging = false;
        });


        // Event Delegation for processing selected duplicates / Skipping
        submitButton.addEventListener('click', async (e) => {
            e.preventDefault(); // Prevent any default behavior

            const checkedCheckboxes = duplicatesList.querySelectorAll('input[type="checkbox"]:checked');

            if (checkedCheckboxes.length > 0) {
                // Process selected duplicates
                const selected_to_reprocess = Array.from(checkedCheckboxes)
                    .map(cb => JSON.parse(cb.dataset.contact)); // Read from data attribute
                await continueProcessing(selected_to_reprocess);
            } else {
                // Skip functionality
                logMessage("Pulando processamento de duplicatas.");
                await continueProcessing([]); // <<< ALTERADO >>> Chama com lista vazia para processar apenas os únicos
                setState({ duplicates: [], isProcessing: false, isLoading: false, vcfPath: '' }); // Clear path and duplicates, return to initial state
            }
        });

        browseVcfBtn.addEventListener('click', async () => {
            const path = await window.pywebview.api.select_file();
            if (path) { // path is a string or None
                 // Call handleVcfPathReady to unify the processing logic for dropped and selected files.
                 handleVcfPathReady(path);
            } else {
                // If file selection was cancelled, clear the input and state
                 vcfPathInput.value = ''; // Clear input field
                 setState({ vcfPath: '' }); // Update state to reflect cleared input
            }
        });

        if (selectAllCheckbox) {
            selectAllCheckbox.addEventListener('change', () => {
                const isChecked = selectAllCheckbox.checked;
                duplicatesList.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = isChecked);
                updateSubmitButtonText();
            });
        }

        if (searchDuplicatesInput) {
            searchDuplicatesInput.addEventListener('input', () => {
                render(state);
            });
        }

        startBtn.addEventListener('click', async () => {
            if (!state.vcfPath) {
                 logMessage("Erro: Por favor, selecione um arquivo VCF primeiro.");
                 return;
            }
            // Call handleVcfPathReady to unify the processing logic
            handleVcfPathReady(state.vcfPath);
        });

        // <<< THIS IS THE CORRECTED AND COMPLETE EVENT LISTENER >>>
        startTextBtn.addEventListener('click', async () => {
            const textContent = textContentArea.value.trim();
            if (!textContent) {
                logMessage("Erro: Por favor, cole o texto dos contatos na área designada.");
                return;
            }
            setState({ isLoading: true, logMessages: [] });
            logMessage("Processando texto...");
            try {
                const response = await fetch('/start_text_processing', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text_content: textContent })
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || "Erro desconhecido no servidor.");

                // CORRECTED LOGIC: Check if the backend already finished and sent a file link.
                if (data.output_file && data.output_file !== "None") {
                    // SUCCESS CASE (NO DUPLICATES): The process is complete. Just display the result.
                    logMessage(`<strong>${data.message}</strong> Arquivo de saída: <a href="#" class="output-link" data-path="${data.output_file}">${data.output_file}</a>`);
                    showSuccessFlash();
                    textContentArea.value = ''; // Clear the text area on success
                } else if (data.duplicates && data.duplicates.length > 0) {
                    // DUPLICATE CASE: The process is paused. Show the user the duplicate selection screen.
                    showDuplicateSelector(data.duplicates);
                } else {
                    // FALLBACK: Should not happen often, but handles cases where there's no file and no duplicates.
                    logMessage(data.message || "Processamento concluído, mas nenhum arquivo foi gerado.");
                }

            } catch (error) {
                logMessage(`Erro: ${error.message}`);
                showErrorShake();
            } finally {
                setState({ isLoading: false });
            }
        });

        // view-log-button listener
        viewLogBtn.addEventListener('click', async () => {
            window.pywebview.api.open_log_file_with_notepad();
        });

        // Check for updates
        if (checkUpdatesBtn) {
            checkUpdatesBtn.addEventListener('click', async () => {
            checkUpdatesBtn.disabled = true;
            checkUpdatesBtn.textContent = 'Verificando...';
            updateStatus.textContent = '';
            
            try {
                const response = await fetch('/check_updates');
                const data = await response.json();
                
                if (data.update_available) {
                    updateStatus.innerHTML = `Nova versão ${data.version} disponível!<br><a href="#" onclick="window.pywebview.api.open_file_path('${data.download_url}')">Baixar Atualização</a>`;
                } else {
                    updateStatus.textContent = 'Você está usando a versão mais recente.';
                }
            } catch (error) {
                updateStatus.textContent = 'Erro ao verificar atualizações.';
            } finally {
                checkUpdatesBtn.disabled = false;
                checkUpdatesBtn.textContent = 'Verificar Atualizações';
            }
            });
        }

        // Event Delegation for log output links
        logArea.addEventListener('click', (e) => {
            if (e.target.classList.contains('output-link')) {
                e.preventDefault();
                const filePath = e.target.dataset.path;
                // Call the new Python API function to open the file
                window.pywebview.api.open_file_path(filePath);
                console.log(`Opening file: ${filePath}`);
            }
        });

        configGearBtn.addEventListener('click', (e) => { e.preventDefault(); setState({ showAdvanced: !state.showAdvanced }); }); // Toggle advanced state
        
        // Panel tab click handler
        const panelTab = document.getElementById('panel-tab');
        panelTab.addEventListener('click', (e) => { e.preventDefault(); setState({ showAdvanced: !state.showAdvanced }); });

        // Make button containers clickable
        document.addEventListener('click', (e) => {
            const buttonContainer = e.target.closest('.button-container');
            if (buttonContainer && !e.target.matches('button')) {
                const button = buttonContainer.querySelector('button');
                if (button) button.click();
            }
        });
        closeBtn.addEventListener('click', () => window.pywebview.api.close_window());
        minimizeBtn.addEventListener('click', () => window.pywebview.api.minimize_window());

        titlebar.addEventListener('mousedown', (e) => {
            if (e.button !== 0 || e.target.closest('.window-controls')) return;
            e.preventDefault();
            const dragOffsetX = e.screenX - window.screenX;
            const dragOffsetY = e.screenY - window.screenY;
            // Disable light follow during drag
            const originalLightMode = lightMode;
            lightMode = 'static';
            updateLightPosition(); // Force static position during drag

            const onMouseMove = (ev) => window.pywebview.api.set_window_position(ev.screenX - dragOffsetX, ev.screenY - dragOffsetY);
            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                // Restore original light mode after drag ends
                lightMode = originalLightMode;
            };
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        // Click outside to close advanced panel
        document.addEventListener('mousedown', (e) => {
            const panel = document.getElementById('advanced-panel');
            const toggle = document.getElementById('config-gear-btn');
            const panelTab = document.getElementById('panel-tab');
            if (state.showAdvanced && !panel.contains(e.target) && !toggle.contains(e.target) && !panelTab.contains(e.target)) { // Check state
                setState({ showAdvanced: false }); // Update state
            }
        });

        // Corrected Auto-Start Logic
        const initialDuplicatesData = JSON.parse('{{ initial_duplicates | safe }}');
        const initialVcfPath = document.getElementById('vcf-path').value; // Get path from input initialized by Flask

        if (Array.isArray(initialDuplicatesData) && initialDuplicatesData.length > 0) {
            // If duplicates were passed initially (headless found duplicates)
            showDuplicateSelector(initialDuplicatesData); // Use helper to set state and log
            setState({ vcfPath: initialVcfPath }); // Ensure vcfPath state is set from initial value
            updateSubmitButtonText(); // Initial button text update based on auto-started duplicates
        } else if (initialVcfPath) {
             // If a path exists initially but no duplicates were passed (implying headless processing of unique)
            logMessage("Processamento sem interface concluído: Nenhuma duplicata encontrada.");
            // Reset state to initial form after successful headless processing without duplicates
            setState({ isLoading: false, isProcessing: false, duplicates: [], vcfPath: initialVcfPath, error: null });
        }
        // If no initial path or duplicates, the form remains in its initial state.

    });
</script>
</body>
</html>