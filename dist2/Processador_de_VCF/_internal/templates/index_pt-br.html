<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>{{ window_title }}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <style>
        .container { height: 100%; display: flex; flex-direction: column; }
        #main-content-area { overflow-y: auto; flex-grow: 1; padding-right: 15px;  --fade-amount: 8%; -webkit-mask-image: linear-gradient(to bottom, transparent, black var(--fade-amount), black calc(100% - var(--fade-amount)), transparent); mask-image: linear-gradient(to bottom, transparent, black var(--fade-amount), black calc(100% - var(--fade-amount)), transparent); }
        #duplicate-selection { padding: 20px; border: 1px solid #ccc; border-radius: 8px; margin-top: 20px; }
        #duplicates-list { max-height: 300px; flex-grow: 1; margin-bottom: 15px; border: 1px solid #ddd; padding: 10px; }
        .duplicate-item { display: flex; align-items: center; padding: 5px; border-bottom: 1px solid #eee; }
        #title-manager { margin-top: 20px; }
        #filtered-titles-list { list-style: none; padding: 0; max-height: 150px; overflow-y: auto; border: 1px solid #ddd; margin-bottom: 10px; }
        #filtered-titles-list li { display: flex; justify-content: space-between; align-items: center; padding: 5px 8px; border-bottom: 1px solid #eee; }
        .delete-title-btn { cursor: pointer; color: red; font-weight: bold; border: none; background: none; font-size: 1.2em; }
    </style>
</head>
<body>
    <div class="titlebar" id="titlebar">
        <span class="titlebar-text"></span>
        <div class="window-controls">
            <button class="window-btn minimize" id="minimize-btn" title="Minimizar">–</button>
            <button class="window-btn" id="close-btn" title="Fechar">×</button>
        </div>
    </div>
    <div class="main-wrapper">
        <div class="container" id="vcf-container">
        <h1>{{ window_title }}</h1>
        <div id="duplicate-selection-1" style="display: none; font-family:Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;">Estes contatos já estão no registro. Selecione quais você deseja reprocessar.</label> 
        <div class="button-row">
            <div class="button-container"><button type="button" id="select-all-btn" class="button">Selecionar Todos</button></div>
                        <div class="button-container"><button type="button" id="select-none-btn" class="button">Selecionar Nenhum</button></div>
                        </div>
                        
        </div>
    
            <div id="main-content-area">
                <div id="initial-form">
                    <div class="input-field">
                        <label for="vcf-path">Arquivo VCF:</label>
                        <div style="display: contents;">
                            <input type="text" id="vcf-path" class="input-style" value="{{ vcf_path }}" placeholder="Selecione um arquivo VCF para processar...">
                            <div class="button-container"><button type="button" id="browse-vcf-btn" class="button file-label">Procurar</button></div>
                        </div>
                    </div>
                    <div class="button-container"><button type="button" id="start-btn" class="button">Processar VCF</button></div>
                </div>
                <div id="duplicate-selection-2" style="display: none;">
                    <form id="duplicates-form">
                        <div id="duplicates-list"></div>
                    </form>
                </div>
            </div>
        <div id="duplicate-selection-3" style="display: none;">
            <div class="button-row">
            <div class="button-container"><button id="submit-button" class="button">Processar Selecionados</button>
            </div>
            
            </div>
            </div>
            <div id="log-area" style="display: none; height: 150px;"></div>
        
    <div class="advanced-toggle"><a href="#" id="advanced-toggle-link">Configurações</a></div>
</div>
<div id="advanced-panel">
    <div id="advanced-panel-content" class="advanced-panel">
        <h3 class="h3">Configurações</h3>
        <div id="title-manager">
            <h4 class="h4">Títulos Filtrados</h4>
            <p style="color: var(--gold-color); font-family: Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;">Palavras nesta lista serão removidas dos nomes.</p>
            <ul id="filtered-titles-list" style="color: var(--gold-color); font-family: Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;"></ul>
            <div class="input-field-adv">
                <input type="text" id="new-title-input" placeholder="Adicionar um título para filtrar..." class="input-style-adv">
                <div class="button-container-adv"><button type="button" id="add-title-btn" class="button-adv">+</button></div>
            </div>
        </div>
        <hr>
        <div id="log-manager" style="margin-top: 20px;">
            <h4 class="h4">Lista de Números Processados</h4>
            <div id="view-log-file" class="button-container-adv">
                <button type="button" id="view-log-btn" class="button-adv">Ver Lista</button>
            </div>
        </div>
    </div>
</div>
    </div>

<script>
    let state = {
        isLoading: false,
        isProcessing: false,
        showAdvanced: false,
        vcfPath: document.getElementById('vcf-path').value,
        duplicates: [],
        filteredTitles: [],
        logMessages: [],
        error: null
    };


document.addEventListener('mousemove', (e) => {
    let light = document.querySelector('.light');
    if (!light) {
        light = document.createElement('div');
        light.className = 'light';
        document.body.appendChild(light);
    }
    light.style.left = `${e.clientX}px`;
    light.style.top = `${e.clientY}px`;
    
    document.querySelectorAll('*').forEach(el => {
        const rect = el.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        // Opposite direction calculation
        const dx = centerX - e.clientX;
        const dy = centerY - e.clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const offsetX = dist > 0 ? (dx / dist) * 2 : 0;
        const offsetY = dist > 0 ? (dy / dist) * 2 : 0;
        
        // Apply opposite shadow
        el.style.textShadow = `${offsetX}px ${offsetY}px 5px rgba(0,0,0,0.5)`;
        /*
        // Add box-shadow for certain elements
        if(el.classList.contains('box') || el.classList.contains('input') || el.classList.contains('button-container')) {
            el.style.boxShadow = `${offsetX}px ${offsetY}px 10px rgba(0,0,0,0.3)`;
        } */
    });
});

    // --- Global State & Element References ---
    const vcfPathInput = document.getElementById('vcf-path');
    const startBtn = document.getElementById('start-btn');
    const logArea = document.getElementById('log-area');
    const initialForm = document.getElementById('initial-form');
    const duplicateSelectionDiv1 = document.getElementById('duplicate-selection-1');
    const duplicateSelectionDiv2 = document.getElementById('duplicate-selection-2');
    const duplicateSelectionDiv3 = document.getElementById('duplicate-selection-3');
    const duplicatesForm = document.getElementById('duplicates-form');
    const duplicatesList = document.getElementById('duplicates-list');
    const titlesList = document.getElementById('filtered-titles-list');
    const newTitleInput = document.getElementById('new-title-input');
    const addTitleBtn = document.getElementById('add-title-btn');
    const advancedPanel = document.getElementById('advanced-panel');
    const selectAllBtn = document.getElementById('select-all-btn');
    const selectNoneBtn = document.getElementById('select-none-btn');
    const submitButton = document.getElementById('submit-button');
    const viewLogBtn = document.getElementById('view-log-btn');
    const browseVcfBtn = document.getElementById('browse-vcf-btn');
    const advancedToggleLink = document.getElementById('advanced-toggle-link');
    const closeBtn = document.getElementById('close-btn');
    const minimizeBtn = document.getElementById('minimize-btn');
    const titlebar = document.getElementById('titlebar');


    // --- State Management ---
    function setState(newState) {
        state = { ...state, ...newState };
        render(state);
    }

    // --- Helper Functions (defined at top level) ---
    function logMessage(message) {
        // Append the new message to a *copy* of the logMessages array
        const newLogMessages = [...state.logMessages, message];
        // Update state with the new array
        setState({ logMessages: newLogMessages });
    }

    async function fetchAndDisplayTitles() {
        try {
            const response = await fetch('/get_titles');
            const data = await response.json();
            setState({ filteredTitles: data.titles }); // Update state, render will handle display
        } catch (e) {
            console.error("Failed to fetch titles:", e);
            logMessage(`Erro ao carregar títulos: ${e.message}`); // Log error via state
        }
    }

    async function saveTitles() {
        setState({ isLoading: true }); // Indicate saving is in progress
        const currentTitles = state.filteredTitles; // Use state for current titles
        try {
            await fetch('/save_titles', {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ titles: currentTitles })
            });
            logMessage("Lista de títulos filtrados atualizada.");
        } catch (e) {
             logMessage(`Erro ao salvar títulos: ${e.message}`); // Log error via state
        } finally {
             setState({ isLoading: false }); // Indicate saving is done
        }
    }

    async function continueProcessing(selected_duplicates) {
        setState({ isProcessing: true, duplicates: [], logMessages: [] }); // Clear duplicates, start processing state, clear logs
        logMessage(`Continuando com ${selected_duplicates.length} duplicatas selecionadas...`);
        try {
            const response = await fetch('/reprocess_selected', {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ selected_to_reprocess: selected_duplicates })
            });
            const data = await response.json();
            if (response.ok) {
                 if (data.output_file && data.output_file !== "None") {
                    logMessage(`<strong>${data.message}</strong> Arquivo de saída: <a href="#" class="output-link" data-path="${data.output_file}">${data.output_file}</a>`);
                } else {
                    logMessage(`<strong>${data.message}</strong> Nenhum arquivo de saída foi criado.`);
                }
            } else {
                throw new Error(data.error || 'An unknown server error occurred.');
            }
        } catch (error) {
             logMessage(`Erro: ${error.message}`); // Log error via state
        } finally {
             setState({ isProcessing: false, duplicates: [] }); // End processing, clear duplicates
        }
    }


    function showDuplicateSelector(duplicates) {
        // This function is now primarily responsible for setting the duplicates in state
        setState({ duplicates: duplicates });
        logMessage(`Encontradas ${duplicates.length} duplicatas. Por favor, faça sua seleção.`);
    }

    // --- Render Function ---
    function render(state) {
        // Update VCF Path input
        vcfPathInput.value = state.vcfPath;

        // Show/Hide sections based on state
        const showInitialForm = !state.isLoading && !state.isProcessing && state.duplicates.length === 0;
        const showDuplicateSelection = state.duplicates.length > 0 && !state.isProcessing;

        initialForm.style.display = showInitialForm ? 'block' : 'none';
        duplicateSelectionDiv1.style.display = showDuplicateSelection ? 'block' : 'none';
        duplicateSelectionDiv2.style.display = showDuplicateSelection ? 'block' : 'none';
        duplicateSelectionDiv3.style.display = showDuplicateSelection ? 'block' : 'none';

        // Enable/Disable buttons
        startBtn.disabled = state.isLoading || state.isProcessing || !state.vcfPath;
        selectAllBtn.disabled = state.isLoading || state.isProcessing || state.duplicates.length === 0;
        selectNoneBtn.disabled = state.isLoading || state.isProcessing || state.duplicates.length === 0;
        browseVcfBtn.disabled = state.isLoading || state.isProcessing;
        addTitleBtn.disabled = state.isLoading || state.isProcessing;
        viewLogBtn.disabled = state.isLoading || state.isProcessing;
        newTitleInput.disabled = state.isLoading || state.isProcessing;

        // Submit button text and disabled state
        const checkedCheckboxes = duplicatesList.querySelectorAll('input[type="checkbox"]:checked').length;
        if (state.duplicates.length > 0 && !state.isProcessing) {
            if (checkedCheckboxes > 0) {
                submitButton.textContent = 'Processar Selecionados';
                submitButton.disabled = state.isLoading || state.isProcessing; // Disable if loading/processing
            } else {
                submitButton.textContent = 'Pular';
                submitButton.disabled = state.isLoading || state.isProcessing; // Disable if loading/processing
            }
        } else {
             submitButton.textContent = 'Processar Selecionados'; // Default text when not in duplicate selection
             submitButton.disabled = true; // Disabled when not in duplicate selection
        }


        // Populate Duplicates List
        duplicatesList.innerHTML = ''; // Clear existing
        if (state.duplicates.length > 0) {
            state.duplicates.forEach((contact, index) => {
                const div = document.createElement('div');
                div.className = 'duplicate-item';
                // Ensure value is properly escaped if needed, or use data attributes
                // Use data attribute for contact data instead of value for cleaner HTML and easier parsing
                div.innerHTML = `<input type="checkbox" id="dup-${index}" name="selected_duplicates" data-contact='${JSON.stringify(contact)}'><label for="dup-${index}">${contact.original_name} (${contact.cleaned_number})</label>`;
                duplicatesList.appendChild(div);
            });
        }

        // Populate Filtered Titles List
        titlesList.innerHTML = ''; // Clear existing
        if (state.filteredTitles.length > 0) {
            state.filteredTitles.forEach(title => {
                const li = document.createElement('li');
                li.textContent = title;
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '×';
                deleteBtn.className = 'delete-title-btn'; // Use class for delegation
                li.appendChild(deleteBtn);
                titlesList.appendChild(li);
            });
        }

        // Toggle Advanced Panel visibility
        advancedPanel.classList.toggle('visible', state.showAdvanced);

        // Update Log Area
        logArea.style.display = state.logMessages.length > 0 ? 'block' : 'none';
        logArea.innerHTML = state.logMessages.join('<br>');
        logArea.scrollTop = logArea.scrollHeight; // Auto-scroll to bottom
    }


    // --- Main Initializer ---
    window.addEventListener('pywebviewready', () => {
        // Attach all event listeners once the DOM and pywebview are ready
        fetchAndDisplayTitles();
        render(state); // Initial render call


        // Event Delegation for Delete Title Buttons
        titlesList.addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-title-btn')) {
                const titleToRemove = e.target.parentElement.firstChild.textContent;
                setState({ filteredTitles: state.filteredTitles.filter(title => title !== titleToRemove) });
                saveTitles();
            }
        });

        addTitleBtn.addEventListener('click', () => {
            const newTitle = newTitleInput.value.trim();
            if (newTitle && !state.filteredTitles.includes(newTitle)) { // Prevent adding duplicates
                setState({ filteredTitles: [...state.filteredTitles, newTitle] });
                newTitleInput.value = '';
                saveTitles();
            }
        });

        newTitleInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const newTitle = newTitleInput.value.trim();
                if (newTitle && !state.filteredTitles.includes(newTitle)) { 
                    setState({ filteredTitles: [...state.filteredTitles, newTitle] });
                    newTitleInput.value = '';
                    saveTitles();
                }
            }
        });

        // Event listener for changes within the duplicates list (checkbox clicks)
        duplicatesList.addEventListener('change', (e) => {
            if (e.target.tagName === 'INPUT' && e.target.type === 'checkbox') {
                // No need to re-render the whole list, just update the button text
                updateSubmitButtonText();
            }
        });

        // Function to update submit button text based on checked checkboxes
        function updateSubmitButtonText() {
            const checkedCheckboxes = duplicatesList.querySelectorAll('input[type="checkbox"]:checked').length;
            if (checkedCheckboxes > 0) {
                submitButton.textContent = 'Processar Selecionados';
            } else {
                submitButton.textContent = 'Pular';
            }
        }


        // Event listener for clicking on duplicate list items (to toggle checkbox)
        duplicatesList.addEventListener('click', (e) => {
            const duplicateItem = e.target.closest('.duplicate-item');
            if (duplicateItem && !e.target.classList.contains('delete-title-btn') && e.target.tagName !== 'INPUT') {
                const checkbox = duplicateItem.querySelector('input[type="checkbox"]');
                if (checkbox) {
                    checkbox.checked = !checkbox.checked;
                    updateSubmitButtonText(); // Update button text after toggling
                }
            }
        });


        // Event Delegation for processing selected duplicates / Skipping
        submitButton.addEventListener('click', async (e) => {
            e.preventDefault(); // Prevent any default behavior

            const checkedCheckboxes = duplicatesList.querySelectorAll('input[type="checkbox"]:checked');

            if (checkedCheckboxes.length > 0) {
                // Process selected duplicates
                const selected_to_reprocess = Array.from(checkedCheckboxes)
                    .map(cb => JSON.parse(cb.dataset.contact)); // Read from data attribute
                await continueProcessing(selected_to_reprocess);
            } else {
                // Skip functionality
                logMessage("Pulando processamento de duplicatas.");
                setState({ duplicates: [], isProcessing: false, isLoading: false }); // Return to initial state
            }
        });

        browseVcfBtn.addEventListener('click', async () => {
            const path = await window.pywebview.api.select_file();
            if (path && path.length > 0) {
                 setState({ vcfPath: path[0] }); // Update state
            }
        });

        selectAllBtn.addEventListener('click', () => {
            duplicatesList.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true);
            updateSubmitButtonText(); // Update button text after selecting all
        });
        selectNoneBtn.addEventListener('click', () => {
            duplicatesList.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
            updateSubmitButtonText(); // Update button text after selecting none
        });

        startBtn.addEventListener('click', async () => {
            if (!state.vcfPath) {
                 logMessage("Erro: Por favor, selecione um arquivo VCF primeiro.");
                 return;
            }
            setState({ isLoading: true, logMessages: [] }); // Start loading state, clear logs
            logMessage("Iniciando processamento... Encontrando duplicatas...");
            try {
                const response = await fetch('/start_vcf_processing', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ vcf_path: state.vcfPath })
                });
                const data = await response.json();
                if (response.ok) {
                    if (data.duplicates && data.duplicates.length > 0) {
                        showDuplicateSelector(data.duplicates); // Use the helper to update duplicates state and log
                        setState({ isLoading: false }); // End loading state after duplicates are shown
                        updateSubmitButtonText(); // Initial button text update based on duplicates
                    } else {
                        logMessage("Nenhuma duplicata encontrada. Processando todos os contatos únicos...");
                        await continueProcessing([]); // No duplicates, proceed directly
                    }
                } else {
                    throw new Error(data.error || 'An unknown server error occurred.');
                }
            } catch (error) {
                 logMessage(`Erro: ${error.message}`); // Log error via state
                 setState({ isLoading: false }); // End loading state on error
            }
        });

        // view-log-button listener
        viewLogBtn.addEventListener('click', async () => {
            window.pywebview.api.open_log_file_with_notepad();
        });

        // Event Delegation for log output links
        logArea.addEventListener('click', (e) => {
            if (e.target.classList.contains('output-link')) {
                e.preventDefault();
                const filePath = e.target.dataset.path;
                // Call the new Python API function to open the file
                window.pywebview.api.open_file_path(filePath);
                console.log(`Opening file: ${filePath}`);
            }
        });

        advancedToggleLink.addEventListener('click', (e) => { e.preventDefault(); setState({ showAdvanced: !state.showAdvanced }); }); // Toggle advanced state
        closeBtn.addEventListener('click', () => window.pywebview.api.close_window());
        minimizeBtn.addEventListener('click', () => window.pywebview.api.minimize_window());

        // Titlebar drag listener
        titlebar.addEventListener('mousedown', (e) => {
            if (e.button !== 0 || e.target.closest('.window-controls')) return;
            e.preventDefault();
            const dragOffsetX = e.screenX - window.screenX;
            const dragOffsetY = e.screenY - window.screenY;
            const onMouseMove = (ev) => window.pywebview.api.set_window_position(ev.screenX - dragOffsetX, ev.screenY - dragOffsetY);
            const onMouseUp = () => { document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); };
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

         // Click outside to close advanced panel
        document.addEventListener('mousedown', (e) => {
            const panel = document.getElementById('advanced-panel');
            const toggle = document.getElementById('advanced-toggle-link');
            if (state.showAdvanced && !panel.contains(e.target) && !toggle.contains(e.target)) { // Check state
                setState({ showAdvanced: false }); // Update state
            }
        });

        // Assuming there's a title input field with id 'title-input'
        document.getElementById('new-title-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                // Call function to add title
                addTitle();
            }
        });

        
        // Corrected Auto-Start Logic
        const initialDuplicatesData = JSON.parse('{{ initial_duplicates | safe }}');
        if (Array.isArray(initialDuplicatesData) && initialDuplicatesData.length > 0) {
            showDuplicateSelector(initialDuplicatesData); // Use helper to set state and log
             updateSubmitButtonText(); // Initial button text update based on auto-started duplicates
        } else if (document.getElementById('vcf-path').value) {
            logMessage("Processamento sem interface concluído: Nenhuma duplicata encontrada.");
        }

    });
</script>
</body>
</html>